// Recursion:
// Fibonacci sequence is generated by adding two numbers to get the subsequent number.
// The sequence can start with 0, 1 or 1, 1:
// 1, 1, 2, 3, 5, 8, 13,...
//
// The formula to generate the Nth value (not by index) in the sequence is:
// Fn = Fn-1 + Fn-2
// F4 = F3 + F2
// 3 = 2 + 1
//
// The time complexity is O(2^n).

function fib(n) {
  if (n < 0) {
    return 0;
  } else if (n < 3) {
    return 1;
  } else {
    return fib(n-1) + fib(n-2);
  }
}

console.log('n = 1: ', fib(1));
console.log('n = 2: ', fib(2));
console.log('n = 5: ', fib(5));
console.log('n = 6: ', fib(6));
console.log('n = 8: ', fib(8));


// Memoized Recursion:
// Memoization (a dynamic programming concept) is an optimization technique that
// stores function calls/results and returns the cached result if the same input occurs.
//
// The time complexity is O(n).

var _cache = [];

function memoFib(n, cache) {
  let result = null;
  // Check if result is cached.
  if (cache[n] !== undefined) {
    return cache[n];
  } else if (n < 1) {
    result = 0;
  } else if (n < 3) {
    result = 1;
  } else {
    result = memoFib(n-1, cache) + memoFib(n-2, cache);
  }
  // Store the result in cache to avoid running the recursive case again or
  // repeating steps when result has been found before.
  cache[n] = result;
  return result;
}

console.log('m = 1: ', memoFib(1, _cache));
console.log('m = 2: ', memoFib(2, _cache));
console.log('m = 3: ', memoFib(3, _cache));
console.log('m = 5: ', memoFib(5, _cache));
console.log('m = 6: ', memoFib(6, _cache));
console.log('m = 8: ', memoFib(8, _cache));
